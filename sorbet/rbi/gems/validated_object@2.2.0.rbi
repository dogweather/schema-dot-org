# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `validated_object` gem.
# Please instead update this file by running `bin/tapioca gem validated_object`.

# source://validated_object//lib/validated_object/version.rb#4
module ValidatedObject; end

# Uses {http://api.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validates ActiveModel::Validations}
# to create self-validating Plain Old Ruby objects. This is especially
# useful when importing data from one system into another. This class also
# creates very readable error messages.
#
# @abstract Subclass and add `attr_accessor` and validations
#   to create custom validating objects.
# @example Writing a self-validating object
#   class Dog < ValidatedObject::Base
#   attr_accessor :name, :birthday
#
#   validates :name, presence: true
#   validates :birthday, type: Date, allow_nil: true
#   end
# @example Instantiating and automatically validating
#   # The dog1 instance validates itself at the end of instantiation.
#   # Here, it succeeds and so doesn't raise an exception.
#   dog1 = Dog.new name: 'Spot'
#
#   # We can also explicitly test for validity
#   dog1.valid?  # => true
#
#   dog1.birthday = Date.new(2015, 1, 23)
#   dog1.valid?  # => true
# @example Making an instance invalid
#   dog1.birthday = '2015-01-23'
#   dog1.valid?  # => false
#   dog1.check_validations!  # => ArgumentError: Birthday is class String, not Date
# @see ValidatedObject::Base::TypeValidator
# @see http://yehudakatz.com/2010/01/10/activemodel-make-any-ruby-object-feel-like-activerecord/ ActiveModel: Make Any Ruby Object Feel Like ActiveRecord, Yehuda Katz
# @see http://www.rubyinside.com/rails-3-0s-activemodel-how-to-give-ruby-classes-some-activerecord-magic-2937.html Rails 3.0â€²s ActiveModel: How To Give Ruby Classes Some ActiveRecord Magic, Peter Cooper
#
# source://validated_object//lib/validated_object.rb#44
class ValidatedObject::Base
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods

  # Instantiate and validate a new object.
  #
  # @example
  #   maru = Dog.new(birthday: Date.today, name: 'Maru')
  # @raise [ArgumentError] if the object is not valid at the
  #   end of initialization or `attributes` is not a Hash.
  #
  # source://validated_object//lib/validated_object.rb#67
  sig { params(attributes: T::Hash[::Symbol, T.untyped]).void }
  def initialize(attributes = T.unsafe(nil)); end

  # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#68
  def __callbacks; end

  # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#68
  def __callbacks?; end

  # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#928
  def _run_validate_callbacks(&block); end

  # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#940
  def _validate_callbacks; end

  # source://activemodel/7.0.4.2/lib/active_model/validations.rb#52
  def _validators; end

  # source://activemodel/7.0.4.2/lib/active_model/validations.rb#52
  def _validators?; end

  # Run any validations and raise an error if invalid.
  #
  # @raise [ArgumentError] if any validations fail.
  #
  # source://validated_object//lib/validated_object.rb#78
  sig { returns(::ValidatedObject::Base) }
  def check_validations!; end

  # source://activemodel/7.0.4.2/lib/active_model/naming.rb#244
  def model_name(*_arg0, **_arg1, &_arg2); end

  # source://activemodel/7.0.4.2/lib/active_model/validations.rb#48
  def validation_context; end

  private

  # source://validated_object//lib/validated_object.rb#154
  sig { params(from_hash: T::Hash[::Symbol, T.untyped]).void }
  def set_instance_variables(from_hash:); end

  # source://activemodel/7.0.4.2/lib/active_model/validations.rb#48
  def validation_context=(_arg0); end

  class << self
    # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#68
    def __callbacks=(value); end

    # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#68
    def __callbacks?; end

    # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#932
    def _validate_callbacks; end

    # source://activesupport/7.0.4.2/lib/active_support/callbacks.rb#936
    def _validate_callbacks=(value); end

    # source://activemodel/7.0.4.2/lib/active_model/validations.rb#52
    def _validators; end

    # source://activemodel/7.0.4.2/lib/active_model/validations.rb#52
    def _validators=(value); end

    # source://activemodel/7.0.4.2/lib/active_model/validations.rb#52
    def _validators?; end
  end
end

# A private class definition, not intended to
# be used directly. Implements a pseudo-boolean class
# enabling validations like this:
#
#   validates :enabled, type: Boolean
#
# source://validated_object//lib/validated_object.rb#57
class ValidatedObject::Base::Boolean; end

# source://validated_object//lib/validated_object.rb#50
ValidatedObject::Base::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://validated_object//lib/validated_object.rb#48
ValidatedObject::Base::SymbolHash = T.type_alias { T::Hash[::Symbol, T.untyped] }

# A custom validator which ensures an object is an instance of a class
# or a subclass. It supports a pseudo-boolean class for convenient
# validation. (Ruby doesn't have a built-in Boolean.)
#
# Automatically used in a `type` validation:
#
# @example Ensure that weight is a number
#   class Dog < ValidatedObject::Base
#   attr_accessor :weight, :neutered
#   validates :weight, type: Numeric  # Typed and required
#   validates :neutered, type: Boolean, allow_nil: true  # Typed but optional
#   end
#
# source://validated_object//lib/validated_object.rb#96
class ValidatedObject::Base::TypeValidator < ::ActiveModel::EachValidator
  # source://validated_object//lib/validated_object.rb#108
  sig { params(record: T.untyped, attribute: T.untyped, value: T.untyped).void }
  def validate_each(record, attribute, value); end

  private

  # source://validated_object//lib/validated_object.rb#132
  sig { params(value: T.untyped).returns(T.untyped) }
  def boolean?(value); end

  # source://validated_object//lib/validated_object.rb#127
  sig { params(expected_class: T.untyped, value: T.untyped).returns(T.untyped) }
  def expected_class?(expected_class, value); end

  # source://validated_object//lib/validated_object.rb#122
  sig { params(expected_class: T.untyped, value: T.untyped).returns(T.untyped) }
  def pseudo_boolean?(expected_class, value); end

  # source://validated_object//lib/validated_object.rb#145
  sig do
    params(
      record: T.untyped,
      attribute: T.untyped,
      value: T.untyped,
      validation_options: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def save_error(record, attribute, value, validation_options); end
end

# source://validated_object//lib/validated_object/version.rb#5
ValidatedObject::VERSION = T.let(T.unsafe(nil), String)
